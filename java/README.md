# Java의 정석 정리

## 삼항 연산자
* 조건 연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이다.
조건식 ? 식1 : 식2  => true:false 


## 향상된 for문
```
for (int tmp: arr) {
 System.out.println(tmp);
}
```
* 향사된 for문은 일반 for문 보다 간결하나 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.

## 배열
* 배열이란? 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 "배열" 이라고 한다.

* char charAt(int index): 문자열에서 해당 위치에 있는 문자를 반환한다.
* int length(): 문자열의 길이를 반환한다.
* String substring(int from, int to): 문자열에서 해당 범위에 있는 문자열을 반환한다.
* boolean equals(Object obj): 문자열의 내용이 obj와 같은지 확인한다.
* char[] toCharArray(): 문자열을 문자배열(char[])로 변환해서 반환한다.


## 객체지향언어
* 객체지향언어는 기존의 프로그래밍 언어에서 몇 가지 새로운 규칙을 추가해 발전된 형태이다. 이러한 규칙들을 이용해서 코드 간에 서로 관계를 맺어 줌으로써 보다 유기적으로 프로그램을 구성하는것이 가능해졌다. 

### 특징
1. 코드의 재사용이 높다.
2. 코드의 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

### 클래스와 객체
* 클래스: 클래스는 객체를 생성하는데 사용된다.
* 객체: 객체가 가지고 있는 기능과 속성에 따라 다름
* 클래스 -> 인스턴스화 -> 인스턴스(객체)



### 변수와 메서드
* 변수는 클래스변수, 인스턴스변수, 지역변수 모두 세 종류가 있다.
* 클래스 변수: 클래스가 메모리에 올라갈 때 생성
* 인스턴스 변수: 인스턴스가 생성되었을 떄 생성
* 지역변수: 변수 선언문이 수행되었을 때 생성

* 메서드: 메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다. 
* 메서드를 사용하는 이유는 높은 재사용성, 중복 코드의 제거,프로그램의 구조화 이렇게 3가지가 대표적이다.
```
메서드의 형식은 선언부와 구현부 
int add(int , int b) {
 int result = a + b;
 return result;
}
```

## JVM의 메모리 구조 
* JVM은 메모리 용도에 따라 여러 영영으로 눈다. 그 3가지를 알아보겠다.

### 메서드 영역(method area)
* 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽어서 분석하여서 클래스 데이터를 이곳에 저장한다.

### 힙 영역(heap)
* 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수들이 생성되는 공간이다.

### 호출스택(call stack)
* 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다.

## 재귀호출
* 메서드의 내부에서 메서드 자신을 다시 호출하는 것을 "재귀호출" 이라고 한다.
```
void method() {
  method();
 }
```
자기 자신을 호출한 메서드는 값에 의한 호출을 통해, 원래의 값이 아닌 복사된 값으로 작업하여 호출한 메서드와 상관없이 독립적인 작업수행이 가능하다.

그렇다면 왜? 재귀호출을 사용해서 자기 자신을 호출할까
* 재귀호출이 주는 논리적 간결함 때문이다. 몇 겹의 반복문과 조건문으로 복잡하게 작성된 코드가 재귀호출로 작성하면 보다 단순한 구조로 바뀔 수 있다.
* 대표적인 예로 팩토리얼이 있다.
```
static int factorial (int n) {
  if (n==1) return 1;
  return n * factorial (n-1);
}
```

# 클래스 메서드와 인스턴스 메서드
* 메서드 앞에 static이 붙어 있으면 클래스메서드이고 붙어 있지 않으면 인스턴스 메서드이다.
* 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요오 하는 메서드이다.
* 인스턴스와 관계없는 메서드를 클래스 메서드(static메서드)로 정의한다.

## 특징
* 1. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다. -> static이 붙은 변수는 클래스가 메모리에 올라갈 때 자동적으로 생성되기 때문이다.
* 2. 클래스 메서드는 인스턴스 변수를 사용할 수 없다. -> 인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스 메서드는 인스턴스 생성 없이 호출이 가능하다.
* 3. 공통된 값을 유지해야하면 static을 붙이자 , 작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려하자


# 오버로딩
* 오버로딩이란 ? 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩 또는 오버로딩이라 한다.
* 
## 오버로딩의 조건 
* 1. 메서드 이름이 같아야 한다.
* 2. 매개변수의 개수 또는 타입이 달라야 한다.
* 주의 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.


## 오버로딩의 대표적 예시
* println 메서드는 값을 넣고 출력 해주는 메서드로 많이 알고 있을 것이다. 
* 실제로 println 메서드는 여러개의 타입으로 정의 되어 있고 매개변수로 넘겨주는 값의 타입에 따라서 오버로딩된 메서드들 중의 하나가 선택되어 실행된다.

## 오버로딩의 장점
* 오버로딩 사용하면 여러 메서드들이 하나의 이름으로 정의될 수 있다. 메서드 이름만 보고도 이 메서드들은 이름이 같으니, 같은 기능을 하겠구나라고 쉽게 예측할 수 있게 된다.
* 메서드의 이름을 절약할 수 있다. 하나의 이름으로 여러개의 메서드를 정의할 수 있으니, 메서드의 이름을 짓는데 고민을 덜 할 수있다.

# 가변인자와 오버로딩
* 메서드의 매개변수 개수가 고정적이었으나 JDK1.5부터 동적으로 지정해 줄 수 있게 되었다. 이 기능을 '가변인자'라고 한다.
* 가변인자는 '타입... 변수명'과 같은 형식으로 선언하고, 매개변수 중에서 제일 마지막에 선언해야 한다.
* 가변인자는 메서드를 호출할 때마다 배열이 새로 생성된다. 가변인자는 꼭 필요한 경우에만 사용하자.


## 생성자
* 생성자란? 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다. 따라서 인스턴스 변수의 초기화 작업에 주로 사용된다.
* 생성자의 이름은 클래스의 이름과 같아야 하고, 리턴값이 없다.


## 기본 생성자
* 모든 클래스에는 반드시 하나의 생성자가 정의되어야 한다. 그러나 클래스에도 정의하지도 않고도 인스턴스를 생성 할 수 있었던 이유는
  기본적으로 제공 해줬기 때문이다. 
* 컴파일러는 자동적으로 기본 생성자를 추가해주지만 클래스 내에 생성자가 하나도 없을 때이니 주의해야한다.

## 생성자에서 다른 생성자 호출하기
* 생성자 간에 서로 호출할 때는 this를 사용하여 호출한다.

```
Car(String color, String gearType) {
this.color = color;
this.gearType = gearType;
}
```
위에 코드를 보면 알 수 있듯이 매개변수로 선언된 변수의 이름과 인스턴스 변수 이름이 서로 구별이 안 된다. 이런 경우에는 인스턴스 변수 앞에 this를 사용하면된다.

## 변수의 초기화
* 변수를 선언하고 처음으로 값을 저장하는 것을 '변수의 초기화'라고 한다.
* 멤버 변수를 사용할때는 초기화를 하지 않아도 되고, 지역변수를 사용할때 초기화를 시켜줘야 한다.

## 변수 초기화 방법
### 명시적 초기화
```
class Car {
 int door = 4;
 Engine e = new Engine();
 }
```

### 초기화 블럭
* 초기화 블럭에는 클래스 초기화 블럭과 인스턴스 초기화 블럭 두 가지 종류가 있다. 
* 작성하는 방법은 class 내부에 블럭{}을 만들고 그안에 코드를 작성하면 된다.


# 객체지향 프로그래밍
* 상속의 정의와 장점
* 상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.
```
class child extends parent {
......
}
```
## 오버라이딩이란
* 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고한다.
* 오버라이딩의 조건 - 1. 이름이 같아야한다.  2. 매개변수가 같아야 한다.  3. 반환타입이 같아야 한다. 

###  주의할 점
* 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
* 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

## 오버라이딩 vs 오버라이딩
* 오버로딩: 기존에 없는 새로운 메서드를 정의하는 것
* 오버라이딩: 상속받은 메서드의 내용을 변경하는 것 -> 쉽게 변수를 넣을 수 있다면 오버라이딩이라고 생각하자

## super
* super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다. 
* this와 마찬가지로 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.

# package 와 import
* 패키지란, 클래스의 묶음이다. 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 효울적으로 관리할 수 있다.

## import
* 소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. 하지만, 매번 패키지명을 붙여서 작성하기는 사용자가 힘들다. 그렇게 해서 나온것이 import문이다. import를 사용하면 클래스이름에서 패키지명을 생략할 수 있다.


# 제어자
* 제어자는 클래스, 변수 또는 메서더의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 

## 제어자의 종류
* static - 클래스 또는 공통적인 의미를 갖고 있으며 static 변수는 인스턴스의 관계없이 같은 값을 갖는다.
* final - 마지막 또는 변경될 수 없는 의미를 가지고 있으며 거의 모든 대상에 사용 될 수 있다.
* abstract - 추상의, 미완성의 의미를 가지고 있으며 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.

# 접근 제어자
* 접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역활을 한다.
* public - 접근 제한이 전혀 없다.
* default - 같은 패키지 내에서만 접근이 가능하다.
* private - 같은 클래스 내에서만 접근이 가능하다.
* protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
* public > protected > default > private

## 접근 제어자를 사용하는 이유
* 주된 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다. 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서 접근을 제한하는 것이다.

# 다형성
* 객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 한다.

## 여러 종류의 객체를 배열로 다루기
```
Product p1 = new Tv();
Product p2 = new Computer();
Product p3 = nmew Audio();
```
* 이처럼 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서  다를 수 있다.

# 추상클래스
* 추상클래스란? 비유하자면 미완성 설계도로 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.
* 추상메서드란? 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다.
```
abstract class Player { // 추상클래스
 abstract void playh(int pos); .. 추상메서드
 abstract void stop(); 
}
```

```
class cdPlayer extends Player {
  void play(int currentPos) {
   // 조상의 추상메서드를 구현 
 }

  void stop() {
   // 조상의 추상메서드를 구현
 }
}
```
* cdPlayer 클래스를 만들고 Player를 상속받아 기능들을 완성시킬 수 있다.


# 인터페이스 
* 인터페이스란 일종의 추상 클래스이다. 인터페이스는 구현된 것은 아무것도 없고 밑그림만 그려져 있는 기본 설계도 라고 할 수 있다.

```
interface 인터페이스이름 {
  public static final 상수이름 = 값;
  public abstract 메서드이름(매개변수목록);
}
```
* 인터페이스는 제약사항이 있다.
 + 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
 + 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다. 
* 인터페이스는 다중 상속이 가능하다.

# 내부 클래스
* 내부 클래스는 말 그대로 클래스 내에 선언된 클래스이다.
* 사용하는 이유는 두 클래스의 멤버들 간에 서로 쉽게 접근할 수 있다는 장점과 외부에는 불필요한 클래스를 감춤으로써 코드의 복잡성을 줄이기 떄문에 사용한다.

## 주의할점
* 내부 클래스에서 static변수는 static 클래스에서만 사용할 수 있다.
* final static은 상수이므로 허용한다.


# 예외처리
코드를 짜다보면 다양한 오류 상황을 맞닥트려 프로그램이 종료 된다. 이런 비정상적인 오류 처리를 막는것을 예외 처리 라고한다.

## 계층 구조 
* 모든 예외의 최고 조상은 Exception클래스이이다.
* RuntimeException클래스들은 주로 프로그래머의 실수에 의해서 발생될 수 있는 예외들이다.
* 예외처리를 할 때는 try catch문 으로 비정상적인 종료를 막을 수 있다.


# 컬렉션 프레임웍
* 데이터 군을 저장하는 클래스들을 표준화한 설계
* List,Set의 고통된 부분을 다시 뽑아 Collection 인터페이스를 정의할 수 있다.
 + List: 순서가 있는 데이터의 집합
 + Set: 순서를 유지하지 않는 데이터의 집합
 + Map: 키와 값의 쌍으로 이루어진 데이터의 집합
 
 ## ArrayList
 * ArrayList는 List인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다는 특징이 있다.
 
 
 ## LinkedList
 * LinkedList는 데이터를 읽어오는데 걸리는 시간이 가장 빠르다는 장점을 가지고 있지만 크기 변경x, 비순차적인 데이터의 추가에는 시간이 많이 걸린다.
 
| 컬렉션 | 읽기  |추가/삭제 | 비고 |
| ---  | ---  | ---  | ---  |
| ArrayList  | 빠르다   | 느리다   | 비효율적인 메모리 사용 |
| LinkedList | 느리다   | 빠르다   | 데이터가 많으면 접근성 떨어짐 |

## 스택과 큐
* stack은 마지막에서 저장한 데이터를 가장 먼저 꺼내는 구조 LIFO
* queue는 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 구조 FIFO

* 스택의 활용: 수식계산, 수식괄호검사 웹브라우저 앞 뒤
* 큐의 활용: 최근사용문서, 인쇄작업 대기목록

## HashMap
* HashMap은 Map을 구현했으므로 앞에서 살펴본 Map의 특징, 키와 값을 묶어서 하나의 데이터로 저장한다는 특징을 갖는다.


# 제네릭
* 제네릭은 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다.
* 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.

```
class box<T> { // 제네릭 타입 T
...
  }
```

## 제한된 제네릭 클래스
* <T extends Fruit> 이런식으로 제한성을 둘 수 있다.

## 제네릭 메서드
* 메서드의 선언부에 제네릭 타입이 선언된 메서드를 제네릭 메서드라고 한다.
```
static <T> void sort(....) 
```

# 열거형
* 열거형은 서로 관련된 상수를 선언하기 위한 것으로 여러 상수를 정의할 때 사용하면 유용하다.
```
class Card {
 enum Kind {CLOVER, HEART, DIAMOND, SPADE} // 열거형 Kind를 정의
 
 final Kind kind; // 타입이 int가 아닌 KINdlek.
}
```

## 열거형 정의 하는 방법
```
enum 열거형이름 { 상수명1, 상수명2, ...}
```
* 열거형 상수간의 비교는 == 를 사용할 수 있다.
* 하지만 비교연산자는 불가능하고 비교할려면 compareTo()를 이용해야한다.

